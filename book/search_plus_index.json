{"./":{"url":"./","title":"Python","keywords":"","body":"Python Python 是一种易于扩展、功能强大、面向对象的编程语言。 "},"docs/快速入门.html":{"url":"docs/快速入门.html","title":"快速入门","keywords":"","body":"快速入门 最简单的运行 Python 程序的方法就是使用命令行，执行下面的命令。 python >>> print('Hello World!') 也可以通过命令行运行指定的 Python 文件，新建 main.py 文件内容如下。 print('Hello World!') 然后打开命令行，执行下面的命令。 python main.py 当然，还可以使用集成开发工具 PyCharm 编辑和运行指定的 Python 程序。 "},"docs/基础语法.html":{"url":"docs/基础语法.html","title":"基础语法","keywords":"","body":"基础语法 标识符 变量赋值 代码注释 行与缩进 "},"docs/基础语法/标识符.html":{"url":"docs/基础语法/标识符.html","title":"标识符","keywords":"","body":"标识符 标识符由字母、数字和下划线组成，其中第一个字符必须是字母或下划线，且严格区分大小写。 注意，标识符禁止使用保留关键字。 "},"docs/基础语法/变量赋值.html":{"url":"docs/基础语法/变量赋值.html","title":"变量赋值","keywords":"","body":"变量赋值 在 Python 中，变量本身是没有类型的，或者说，它们在赋值时才具有类型。可以在任何时候改变一个变量的类型，而不需要事先声明其类型。 x = 233 print(x) x = 6.66 print(x) x = 'Hello World!' print(x) 执行下面的代码，一次为多个变量赋值。 num1, num2, num3 = 233, 6.66, 4 + 3j print(num1, num2, num3) "},"docs/基础语法/代码注释.html":{"url":"docs/基础语法/代码注释.html","title":"代码注释","keywords":"","body":"代码注释 在 Python 中有两种主要的代码注释方式，分别为单行注释、多行注释。 # 单行注释 \"\"\" 多行注释 \"\"\" "},"docs/基础语法/行与缩进.html":{"url":"docs/基础语法/行与缩进.html","title":"行与缩进","keywords":"","body":"行与缩进 Python 最具特色的就是使用缩进来表示代码块，同一个代码块的语句必须包含相同的缩进空格数。 if 1 + 1 == 2: print(True) else: print(False) 若语句缩进的空格数不一致，将会导致运行错误。 if 1 + 1 == 2: print(True) print(233) else: print(False) print(666) "},"docs/数据类型.html":{"url":"docs/数据类型.html","title":"数据类型","keywords":"","body":"数据类型 数值类型 字符串类型 布尔类型 列表类型 元组类型 集合类型 字典类型 小数类型 分数类型 类型转换 "},"docs/数据类型/数值类型.html":{"url":"docs/数据类型/数值类型.html","title":"数值类型","keywords":"","body":"数值类型 Python 中的数值类型主要包括整型、浮点型、布尔型和复数型。 num = 233 print(num, type(num)) num = 6.66 print(num, type(num)) num = True print(num, type(num)) num = 4 + 3j print(num, type(num)) "},"docs/数据类型/字符串类型.html":{"url":"docs/数据类型/字符串类型.html","title":"字符串类型","keywords":"","body":"字符串类型 在 Python 中，字符串是由单字符所组成的序列。 str = 'Hello World!' print(str, type(str)) str = \"Hello World!\" print(str, type(str)) str = \"\"\"Hello World!\"\"\" print(str, type(str)) 字符串截取与拼接的语法格式如下。 str = 'Hello World!' print(str[0]) print(str[:]) print(str[2:7]) print(str[2:]) print(str[-1:]) print(str[:-1]) print(str * 2) print(str + ' Python!') print(str[-1::-1]) 如果不想转义特殊字符，可以在字符串前添加字符 r 表示原始字符串。 str = 'Hello \\n World!' print(str) str = r'Hello \\n World!' print(str) 还可以通过以下方式格式化输出字符串。 str1 = 'Hello' str2 = 'Python' print('%s %s!' % (str1, str2)) print(f'{str1} {str2}!') print('{} {}!'.format(str1, str2)) print('{0} {1}!'.format(str1, str2)) print('{str1} {str2}!'.format(str1='Hello', str2='Python')) 执行下面的代码，检测字符串中是否包含子字符串。 str = 'Hello World!' print(str.find('o')) print(str.find('o', 5)) print(str.find('o', 8)) 执行下面的代码，检测字符串中是否包含子字符串，否则抛出异常。 str = 'Hello World!' print(str.index('o')) print(str.index('o', 5)) print(str.index('o', 8)) 执行下面的代码，统计字符串里某个字符出现的次数。 str = 'Hello World!' print(str.count('o')) print(str.count('o', 5)) print(str.count('Hello')) 执行下面的代码，用新字符串替换旧字符串。 str = 'Hello World!' print(str.replace('World', 'Python')) 执行下面的代码，通过指定分隔符对字符串进行切片，并返回由子字符串组成的列表。 str = 'Hello World! Welcome to Python!' print(str.split(' ')) 执行下面的代码，将字符串的第一个字母变成大写，其他字母变小写。 str = 'Hello World!' print(str.capitalize()) 执行下面的代码，检查字符串是否是以指定子字符串开头。 str = 'Hello World!' print(str.startswith('Hello')) 执行下面的代码，检查字符串是否是以指定子字符串结尾。 str = 'Hello World!' print(str.endswith('World')) print(str.endswith('World!')) 执行下面的代码，转换字符串中所有大写字符为小写。 str = 'Hello World!' print(str.lower()) 执行下面的代码，转换字符串中所有小写字符为大写。 str = 'Hello World!' print(str.upper()) "},"docs/数据类型/布尔类型.html":{"url":"docs/数据类型/布尔类型.html","title":"布尔类型","keywords":"","body":"布尔类型 布尔类型只有两个值，可以用来控制程序的流程。 print(True, type(True)) print(False, type(False)) "},"docs/数据类型/列表类型.html":{"url":"docs/数据类型/列表类型.html","title":"列表类型","keywords":"","body":"列表类型 列表中的元素类型可以不相同，主要用来实现集合类的数据结构。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] print(list) 也可以通过构造函数的方式来初始化列表。 list = list({233, 6.66, True, 4 + 3j, 'Hello World!'}) print(list) 与字符串相同，列表同样可以被索引、截取、拼接。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] print(list[0]) print(list[:]) print(list[1:3]) print(list[2:]) print(list[-1:]) print(list[:-1]) print(list * 2) print(list + [1, 2, 3]) print(list[-1::-1]) 列表可以进行多个层次的嵌套。 matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(matrix) print(matrix[0]) print(matrix[1][2]) Python 推导式是一种独特的数据处理方式，可以用一个数据序列构建另一个新数据序列的结构体。 [print(i) for i in range(1, 6)] [print(i) for i in range(1, 6) if i % 2 == 1] 执行下面的代码，在列表末尾添加新的元素。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] list.append('Hello Python!') print(list) 执行下面的代码，在列表末尾一次性追加另一个序列中的多个值。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] list.extend([1, 2, 3]) print(list) list.extend({'4', '5', '6'}) print(list) list.extend({'name': 'Google', 'site': 'www.google.com'}) print(list) 执行下面的代码，将指定对象插入列表的指定位置。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] list.insert(0, 'Google') print(list) list.insert(len(list), 'Facebook') print(list) 执行下面的代码，统计某个元素在列表中出现的次数。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] print(list.count(233)) print(list.count('233')) 执行下面的代码，从列表中查找指定元素第一个匹配项的索引位置。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] print(list.index(6.66)) print(list.index('Hello World')) 执行下面的代码，删除列表中的指定元素。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] del list[2] print(list) 执行下面的代码，删除列表中的指定元素，默认最后一个元素。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] print(list.pop()) print(list) list.pop(2) print(list) 执行下面的代码，移除列表中指定值的第一个匹配项元素。 list = [233, 6.66, True, 4 + 3j, 'Hello World!'] list.remove(6.66) print(list) 执行下面的代码，对列表中的元素进行排序。 list = ['Google', 'Facebook', 'TikTok'] list.sort() print(list) list.sort(reverse=True) print(list) 执行下面的代码，对列表中的元素进行反向排序。 list = ['Google', 'Facebook', 'TikTok'] list.reverse() print(list) "},"docs/数据类型/元组类型.html":{"url":"docs/数据类型/元组类型.html","title":"元组类型","keywords":"","body":"元组类型 元组与列表相似，不同之处在于元组中的元素不能修改。 tuple = (233, 6.66, True, 4 + 3j, 'Hello World!') print(tuple) print(tuple[0]) print(tuple[1:3]) print(tuple[2:]) print(tuple[-1:]) print(tuple[:-1]) print(tuple * 2) print(tuple + (1, 2, 3)) print(tuple[-1::-1]) 虽然元组中的元素不可改变，但它可以包含列表类型。 tuple = (233, [6.66, 'Hello World!']) print(tuple) tuple[1][0] = True print(tuple) 也可以通过构造函数的方式来初始化元组。 tuple = tuple({233, 6.66, True, 4 + 3j, 'Hello World!'}) print(tuple) 若只创建仅有一个元素的元组，需要在该元素后面添加一个逗号。 tuple = (233,) print(tuple) 执行下面的代码，统计元组内所有元素个数 tuple = (233, 6.66, True, 4 + 3j, 'Hello World!') print(len(tuple)) 执行下面的代码，返回元组中元素的最大值。 tuple = (1, 2, 3, 4, 5) print(max(tuple)) 执行下面的代码，返回元组中元素的最小值。 tuple = (1, 2, 3, 4, 5) print(min(tuple)) "},"docs/数据类型/集合类型.html":{"url":"docs/数据类型/集合类型.html","title":"集合类型","keywords":"","body":"集合类型 集合是一种无序、可变的数据类型，用于存储唯一的元素。 set = {'Google', 'Facebook', 'Google', 'TikTok'} print(set) 执行下面的代码，查找集合中是否存在指定的元素。 set = {'Google', 'Facebook', 'Google', 'TikTok'} if 'Google' in set: print('Found') else: print('Not Found') 执行下面的代码，对集合进行并集、交集、差集等操作。 set1 = set('adcabde') set2 = set('cdf') print(set1 | set2) print(set1 & set2) print(set1 - set2) print(set1 ^ set2) 创建一个空集合需要使用以下的方式。 set = set() print(set) 执行下面的代码，为集合添加指定元素。 set = {'Google', 'Facebook'} set.add('TikTok') print(set) 执行下面的代码，为集合添加新的元素。 set = {'Google', 'Facebook'} set.update({'TikTok', 'Microsoft'}) print(set) 执行下面的代码，删除并返回集合中的一个随机元素。 set = {'Google', 'Facebook', 'TikTok'} print(set.pop()) print(set) 执行下面的代码，删除集合中的指定元素，当元素不存在时会发生错误。 set = {'Google', 'Facebook', 'TikTok'} set.remove('TikTok') print(set) set.remove('TikTok') 执行下面的代码，删除集合中的指定元素。 set = {'Google', 'Facebook', 'TikTok'} set.discard('TikTok') print(set) set.discard('TikTok') "},"docs/数据类型/字典类型.html":{"url":"docs/数据类型/字典类型.html","title":"字典类型","keywords":"","body":"字典类型 字典是一种映射类型，它是一种无序键值对的集合。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} print(dict) print(dict['id']) print(dict['name']) print(dict['site']) print(dict.keys()) print(dict.values()) 也可以通过构造函数的方式来初始化字典。 dict = dict(id=1, name='Google', site='www.google.com') print(dict) print(dict['id']) print(dict['name']) print(dict['site']) print(dict.keys()) print(dict.values()) 执行下面的代码，查找字典中是否存在指定的键。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} if 'name' in dict: print(dict['name']) else: print('Not Found') 字典也可以进行多个层次的嵌套。 dict = {'name': 'Google', 'management': {'CEO': 'Tom', 'CTO': 'Jerry'}} print(dict) print(dict['management']) 执行下面的代码，统计字典中所有元素的个数。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} print(len(dict)) 执行下面的代码，返回字典中指定键的值。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} print(dict.get('id')) print(dict.get('name')) print(dict.get('site')) print(dict.get('management')) 执行下面的代码，删除字典中指定键的值，然后删除该字典。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} del dict['id'] print(dict) del dict print(dict) 执行下面的代码，清空字典中所有元素。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} dict.clear() print(dict) 执行下面的代码，返回字典中所有键名。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} print(dict.keys()) 执行下面的代码，返回字典中所有键值。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} print(dict.values()) 执行下面的代码，返回字典中所有键值对。 dict = {'id': 1, 'name': 'Google', 'site': 'www.google.com'} print(dict.items()) "},"docs/数据类型/小数类型.html":{"url":"docs/数据类型/小数类型.html","title":"小数类型","keywords":"","body":"小数类型 浮点数运算缺乏精确性，而使用小数类型结果将更精准。 from decimal import Decimal print(0.1 + 0.1 + 0.1 - 0.3) print(Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')) "},"docs/数据类型/分数类型.html":{"url":"docs/数据类型/分数类型.html","title":"分数类型","keywords":"","body":"分数类型 分数类型显示保留了分子与分母，从而避免了浮点数运算的局限性。 from fractions import Fraction print(Fraction(1, 3)) print(Fraction(1, 5)) print(Fraction(1, 3) - Fraction(1, 5)) "},"docs/数据类型/类型转换.html":{"url":"docs/数据类型/类型转换.html","title":"类型转换","keywords":"","body":"类型转换 执行下面的代码，将对象的数据类型显示转换为所需的数据类型。 num1 = int(6.66) print(num1, type(num1)) num2 = int('233') print(num2, type(num2)) num3 = float(233) print(num3, type(num3)) num4 = float('6.66') print(num4, type(num4)) str1 = str(233) print(str1, type(str1)) str2 = str(2.33) print(str2, type(str2)) 执行下面的代码，运行字符串表达式，并返回表达式的值。 print(eval('233 + 666')) num = 2 print(eval('num ** num')) "},"docs/深浅拷贝.html":{"url":"docs/深浅拷贝.html","title":"深浅拷贝","keywords":"","body":"深浅拷贝 在 Python 中，对象赋值实际上是对象的引用。当创建一个对象，然后把它赋给另一个变量的时候， Python 并没有拷贝这个对象，而是拷贝了这个对象的引用。 list1 = [1, 2, 3, [4, 5, 6]] list2 = list1 print(list1, id(list1)) print(list2, id(list2)) list1.append(7) print(list1, id(list1)) print(list2, id(list2)) 执行下面的代码，对列表进行浅拷贝操作。注意，浅拷贝操作不会拷贝对象内部的子对象。 import copy list1 = [1, 2, 3, [4, 5, 6]] list2 = copy.copy(list1) print(list1, id(list1)) print(list2, id(list2)) list1.append(7) print(list1, id(list1)) print(list2, id(list2)) list1[3].append(233) print(list1, id(list1)) print(list2, id(list2)) 为了使赋值操作时两个变量互不影响，可以对列表进行深拷贝操作。 import copy list1 = [1, 2, 3, [4, 5, 6]] list2 = copy.deepcopy(list1) print(list1, id(list1)) print(list2, id(list2)) list1.append(7) print(list1, id(list1)) print(list2, id(list2)) list1[3].append(233) print(list1, id(list1)) print(list2, id(list2)) "},"docs/运算符.html":{"url":"docs/运算符.html","title":"运算符","keywords":"","body":"运算符 算术运算符 关系运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 "},"docs/运算符/算术运算符.html":{"url":"docs/运算符/算术运算符.html","title":"算术运算符","keywords":"","body":"算术运算符 执行下面的代码，进行算术运算。 num1 = 10 num2 = 3 print(num1 + num2) print(num1 - num2) print(num1 * num2) print(num1 / num2) print(num1 // num2) print(num1 % num2) print(num1 ** num2) "},"docs/运算符/关系运算符.html":{"url":"docs/运算符/关系运算符.html","title":"关系运算符","keywords":"","body":"关系运算符 执行下面的代码，进行关系运算。 num1 = 10 num2 = 3 print(num1 == num2) print(num1 != num2) print(num1 > num2) print(num1 >= num2) print(num1 "},"docs/运算符/赋值运算符.html":{"url":"docs/运算符/赋值运算符.html","title":"赋值运算符","keywords":"","body":"赋值运算符 执行下面的代码，进行赋值运算。 num = 233 num += 6 print(num) num -= 6 print(num) num *= 2 print(num) num /= 2 print(num) num = 233 num //= 2 print(num) num = 233 num %= 2 print(num) num = 233 num **= 2 print(num) "},"docs/运算符/逻辑运算符.html":{"url":"docs/运算符/逻辑运算符.html","title":"逻辑运算符","keywords":"","body":"逻辑运算符 执行下面的代码，进行逻辑运算。 num1 = 1 num2 = 0 if num1 and num2: print('And') if num1 or num2: print('Or') if not num1: print('No.1') if not num2: print('No.2') if not (num1 and num2): print('No.3') "},"docs/运算符/位运算符.html":{"url":"docs/运算符/位运算符.html","title":"位运算符","keywords":"","body":"位运算符 执行下面的代码，进行位运算。 num1 = 5 num2 = 2 print(num1 & num2) print(num1 | num2) print(num1 ^ num2) print(~num1) print(num1 > 2) "},"docs/运算符/成员运算符.html":{"url":"docs/运算符/成员运算符.html","title":"成员运算符","keywords":"","body":"成员运算符 执行下面的代码，判断字符串中是否包含指定子字符串。 str = 'Hello World!' print('Hello' in str) print('Hello' not in str) "},"docs/条件控制.html":{"url":"docs/条件控制.html","title":"条件控制","keywords":"","body":"条件控制 if-else if-elif match for while break continue "},"docs/条件控制/if-else.html":{"url":"docs/条件控制/if-else.html","title":"if-else","keywords":"","body":"if-else 执行下面的代码，进行条件判断。 num = 233 if num > 0: print('Yes') else: print('No') 条件判断语句可以进行嵌套。 num = 233 if num > 0: print('Yes') if num > 100: print(666) else: print(num) else: print('No') 也可以使用更加简洁的三元表达式。 num = 233 print('Yes') if num > 0 else print('No') "},"docs/条件控制/if-elif.html":{"url":"docs/条件控制/if-elif.html","title":"if-elif","keywords":"","body":"if-elif Python 中允许连接多个条件判断来执行范围比较。 num = 95 if 90 "},"docs/条件控制/match.html":{"url":"docs/条件控制/match.html","title":"match","keywords":"","body":"match 执行下面的代码，进行多路判定。 num = 233 match num: case 0: print(0) case 233: print(233) case 666: print(666) case _: print('Other') "},"docs/条件控制/for.html":{"url":"docs/条件控制/for.html","title":"for","keywords":"","body":"for 执行下面的代码，进行条件循环。 for i in range(1, 10): print(i) 条件循环末尾可搭配条件判断语句。 for i in range(1, 10): print(i) else: print('End') "},"docs/条件控制/while.html":{"url":"docs/条件控制/while.html","title":"while","keywords":"","body":"while 执行下面的代码，进行条件循环。 num = 9 while num > 0: print(num) num -= 1 条件循环末尾可搭配条件判断语句。 num = 9 while num > 0: print(num) num -= 1 else: print('End') "},"docs/条件控制/break.html":{"url":"docs/条件控制/break.html","title":"break","keywords":"","body":"break 执行下面的代码，在循环中根据指定条件跳出循环。 num = 9 while num > 0: if num == 6: break print(num) num -= 1 "},"docs/条件控制/continue.html":{"url":"docs/条件控制/continue.html","title":"continue","keywords":"","body":"continue 执行下面的代码，在循环中根据指定条件进行下一次循环。 num = 9 while num > 0: if num == 6: num -= 1 continue print(num) num -= 1 "},"docs/函数功能.html":{"url":"docs/函数功能.html","title":"函数功能","keywords":"","body":"函数功能 函数定义 函数返回值 必需参数 默认参数 可变参数 关键字参数 递归函数 函数嵌套 局部变量 全局变量 匿名函数 内置函数 闭包 装饰器 解包 "},"docs/函数功能/函数定义.html":{"url":"docs/函数功能/函数定义.html","title":"函数定义","keywords":"","body":"函数定义 执行下面的代码，定义并调用指定函数。 def func1(): print('Hello World!') def func2(): print('Hello Python!') func1() func2() "},"docs/函数功能/函数返回值.html":{"url":"docs/函数功能/函数返回值.html","title":"函数返回值","keywords":"","body":"函数返回值 在 Python 中，函数可以有零个、一个或多个返回值。 def func1(): print('Hello World!') def func2(): print('Hello Python!') return 'Hello Python!' def func3(): print(233, 6.66) return 233, 6.66 print(func1()) print(func2()) print(func3()) "},"docs/函数功能/必需参数.html":{"url":"docs/函数功能/必需参数.html","title":"必需参数","keywords":"","body":"必需参数 必需参数要以正确的顺序传入函数，调用时的数量必须和声明时的一样。 def max(a, b): return a if a > b else b def min(a, b): return a if a "},"docs/函数功能/默认参数.html":{"url":"docs/函数功能/默认参数.html","title":"默认参数","keywords":"","body":"默认参数 调用函数时，如果没有传递参数，则会使用默认参数。 def func(name, age=18): print(name, age) func('Tom', 20) func('Jerry') "},"docs/函数功能/可变参数.html":{"url":"docs/函数功能/可变参数.html","title":"可变参数","keywords":"","body":"可变参数 可变参数会以元组的形式导入，存放所有未命名的变量参数。 def func(*args): print(args) func() func(233) func(1, 2, 3, 4, 5) "},"docs/函数功能/关键字参数.html":{"url":"docs/函数功能/关键字参数.html","title":"关键字参数","keywords":"","body":"关键字参数 关键字参数是在调用函数时，通过参数名显式指定参数值的参数传递方式 def func(**kwargs): print(kwargs) func() func(name='Tom', age=20) func(name='Jerry', age=18, gender='female') "},"docs/函数功能/递归函数.html":{"url":"docs/函数功能/递归函数.html","title":"递归函数","keywords":"","body":"递归函数 递归函数是一种通过函数自身调用自身来解决复杂问题的方式。 def fib(n): if n "},"docs/函数功能/函数嵌套.html":{"url":"docs/函数功能/函数嵌套.html","title":"函数嵌套","keywords":"","body":"函数嵌套 执行下面的代码，在一个函数中调用另一个函数。 def func1(): print('Hello World!') def func2(): func1() print('Hello Python!') func1() func2() 执行下面的代码，在一个函数中定义另一个函数。 def func1(): print('Hello World!') def func2(): print('Hello Python!') func2() func1() "},"docs/函数功能/局部变量.html":{"url":"docs/函数功能/局部变量.html","title":"局部变量","keywords":"","body":"局部变量 函数内部定义的变量从定义位置开始到函数定义结束位置有效。 def func(): num = 233 print(num) func() print(num) "},"docs/函数功能/全局变量.html":{"url":"docs/函数功能/全局变量.html","title":"全局变量","keywords":"","body":"全局变量 函数外部定义的变量在整个文件中有效。 num = 233 def func1(): print(num) def func2(): num = 666 print(num) func1() func2() 也可以在函数内部声明并修改全局变量。 num = 233 def func1(): num = 666 print(num) def func2(): global num num = 666 print(num) func1() print(num) func2() print(num) "},"docs/函数功能/匿名函数.html":{"url":"docs/函数功能/匿名函数.html","title":"匿名函数","keywords":"","body":"匿名函数 匿名函数通常用于编写简单的、单行的函数。 func1 = lambda: print('Hello World!') func1() func2 = lambda a, b: a + b print(func2(233, 666)) func3 = lambda name, age=18: print(name, age) func3('Tom', 20) func3('Jerry') func4 = lambda a, b: a if a > b else b print(func4(233, 666)) "},"docs/函数功能/内置函数.html":{"url":"docs/函数功能/内置函数.html","title":"内置函数","keywords":"","body":"内置函数 执行下面的代码，查看所有内置函数。 import builtins print(dir(builtins)) 执行下面的代码，对列表中所有元素进行求和计算。 print(sum([1, 2, 3, 4, 5])) 执行下面的代码，返回列表中所有元素的最大值。 print(max([1, 2, 3, 4, 5])) 执行下面的代码，返回列表中所有元素的最小值。 print(min([1, 2, 3, 4, 5])) 执行下面的代码，将列表中对应的元素分别打包成元组，然后返回由这些元组组成的列表。 list1 = [1, 2, 3] list2 = ['Google', 'Facebook', 'TikTok'] print(list(zip(list1, list2))) 执行下面的代码，对参数序列中的元素进行累积操作。 from functools import reduce list = [1, 2, 3, 4, 5] def add(a, b): return a + b print(reduce(add, list)) "},"docs/函数功能/闭包.html":{"url":"docs/函数功能/闭包.html","title":"闭包","keywords":"","body":"闭包 在嵌套函数中，内部函数使用了外部函数的变量，而外部函数又返回了内部函数，这样的函数称为闭包。 def outer(): num = 233 def inner(): print(num) return inner print(outer()) outer()() ot = outer() ot() 执行下面的代码，以闭包函数方式传递参数。 def outer(num1): print(num1) def inner(num2): print(num1 + num2) return inner outer(233)(666) "},"docs/函数功能/装饰器.html":{"url":"docs/函数功能/装饰器.html","title":"装饰器","keywords":"","body":"装饰器 装饰器是 Python 中的高级功能，主要用来实现动态修改函数或类的行为。 def outer(fn): print('outer') def inner(): print('inner before') fn() print('inner after') return inner @outer def func(): print('Hello World!') func() 执行下面的代码，实现多个装饰器堆叠，注意此方式将按照从下到上的顺序依次应用。 def deco1(fn): def wrapper(): print('decorator 1') fn() return wrapper def deco2(fn): def wrapper(): print('decorator 2') fn() return wrapper @deco1 @deco2 def func(): print('Hello World!') func() "},"docs/函数功能/解包.html":{"url":"docs/函数功能/解包.html","title":"解包","keywords":"","body":"解包 在 Python 中，解包是一种将可迭代对象中的元素赋值给多个变量的操作。 tuple = (1, 2, 3) print(tuple) num1, num2, num3 = tuple print(num1, num2, num3) num1, *num2 = tuple print(num1, num2) "},"docs/异常处理.html":{"url":"docs/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 触发异常 捕获异常 "},"docs/异常处理/触发异常.html":{"url":"docs/异常处理/触发异常.html","title":"触发异常","keywords":"","body":"触发异常 异常是 Python 中的对象，表示程序运行发生错误。执行下面的代码，触发自定义异常。 raise Exception('Hello World!') print('Hello World!') "},"docs/异常处理/捕获异常.html":{"url":"docs/异常处理/捕获异常.html","title":"捕获异常","keywords":"","body":"捕获异常 执行下面的代码，捕获触发的异常。 def func(): raise Exception('Hello World!') try: func() except Exception as e: print(e) print('Hello Python!') "},"docs/包管理器.html":{"url":"docs/包管理器.html","title":"包管理器","keywords":"","body":"包管理器 pip 导入模块 导入包 "},"docs/包管理器/pip.html":{"url":"docs/包管理器/pip.html","title":"pip","keywords":"","body":"pip pip 是 Python 的包管理工具。打开命令行，执行下面的命令，列出已安装的 Python 包及其版本号。 pip list 执行下面的命令，安装指定的 Python 包。 pip install numpy 执行下面的命令，卸载指定的 Python 包。 pip uninstall numpy 执行下面的代码，验证是否安装成功。 import numpy print(numpy.__version__) "},"docs/包管理器/导入模块.html":{"url":"docs/包管理器/导入模块.html","title":"导入模块","keywords":"","body":"导入模块 执行下面的代码，导入整个模块。 import math print(math.sqrt(16)) 执行下面的代码，从模块中导入指定的对象。 from math import sqrt print(sqrt(16)) 执行下面的代码，从模块中导入所有对象。 from math import * print(sqrt(16)) 在当前项目新建 demo.py 文件内容如下。 def func(): print('Hello World!') print('Hello Python!') 执行下面的代码，导入指定模块并使用别名。 import demo as d d.func() 当模块作为独立脚本运行时， __name__ 的值为 __main__ 。当模块被其他模块导入时， __name__ 的值为模块名。在当前项目目录下新建 demo.py 文件，执行下面的代码。 if __name__ == '__main__': print('Hello World!') else: print(__name__) "},"docs/包管理器/导入包.html":{"url":"docs/包管理器/导入包.html","title":"导入包","keywords":"","body":"导入包 打开 PyCharm ，在当前项目新建名为 demo 的软件包，完成后该软件包目录下将自动生成 __init__.py 文件，添加代码如下。 def func(): print('Hello World!') print('Hello Python!') 执行下面的代码，导入该软件包并调用指定函数。 import demo demo.func() 在 demo 软件包中新建 register.py 与 login.py 文件，分别添加代码如下。 def func1(): print('registered successfully') def func2(): print('login successfully') 随后修改 __init__.py 代码如下。 from demo import register from demo import login 执行下面的代码，导入该软件包中所有模块，并分别调用相关函数。 import demo demo.register.func1() demo.login.func2() "},"docs/面向对象.html":{"url":"docs/面向对象.html","title":"面向对象","keywords":"","body":"面向对象 类和对象 构造函数 析构函数 私有属性 私有方法 继承 静态方法 单例模式 魔术方法 "},"docs/面向对象/类和对象.html":{"url":"docs/面向对象/类和对象.html","title":"类和对象","keywords":"","body":"类和对象 类属性属于类本身，实例属性属于对象。执行下面的代码，定义类属性与类方法并进行调用。 class Person: name = 'Tom' age = 20 def call(self): print(self.name, self.age) print(Person.name) print(Person.age) Person.gender = 'male' print(Person.gender) p = Person() p.call() print(p.name) print(p.age) print(p.gender) "},"docs/面向对象/构造函数.html":{"url":"docs/面向对象/构造函数.html","title":"构造函数","keywords":"","body":"构造函数 构造函数在类实例化对象时会被自动调用，通常用于为对象进行属性初始化或赋值操作。 class Person: name = 'Tom' age = 20 def __init__(self, name, age): self.name = name self.age = age def call(self): print(self.name, self.age) print(Person.name) print(Person.age) Person.gender = 'male' print(Person.gender) p = Person('Jerry', 18) p.call() print(p.name) print(p.age) print(p.gender) 执行下面的代码，实例化多个不同对象。 class Person: name = 'Tom' age = 20 def __init__(self, name, age): self.name = name self.age = age def call(self): print(self.name, self.age) p1 = Person('Jerry', 18) print(p1) p1.call() p2 = Person('Spike', 22) print(p2) p2.call() "},"docs/面向对象/析构函数.html":{"url":"docs/面向对象/析构函数.html","title":"析构函数","keywords":"","body":"析构函数 析构函数在对象实例被回收时运行，主要被用来执行清理工作。 class Person: name = 'Tom' age = 20 def __init__(self, name, age): self.name = name self.age = age def __del__(self): print('Bye!') p = Person('Jerry', 18) print('Hello World!') del p "},"docs/面向对象/私有属性.html":{"url":"docs/面向对象/私有属性.html","title":"私有属性","keywords":"","body":"私有属性 以两个下划线开头声明的属性为私有属性，私有属性不能在类的外部被使用或直接访问。 class Person: __name = 'Tom' __age = 20 def __init__(self, name, age): self.__name = name self.__age = age def call(self): print(self.__name, self.__age) p = Person('Jerry', 18) p.call() print(p.__name, p.__age) 事实上，私有属性只是将属性名进行修改，可以通过其他方式从外部访问类的私有属性。 class Person: __name = 'Tom' __age = 20 def __init__(self, name, age): self.__name = name self.__age = age def call(self): print(self.__name, self.__age) print(Person._Person__name, Person._Person__age) p = Person('Jerry', 18) print(p._Person__name, p._Person__age) "},"docs/面向对象/私有方法.html":{"url":"docs/面向对象/私有方法.html","title":"私有方法","keywords":"","body":"私有方法 以两个下划线开头声明的方法为私有方法，私有方法只能在类的内部调用，不能在类的外部调用。 class Person: name = 'Tom' age = 20 def __init__(self, name, age): self.name = name self.age = age def call(self): self.__call() def __call(self): print(self.name, self.age) p = Person('Tom', 20) p.call() p.__call() "},"docs/面向对象/继承.html":{"url":"docs/面向对象/继承.html","title":"继承","keywords":"","body":"继承 继承即一个派生类继承基类的属性和方法。 class Person: def call(self): print('Hello World!') class Student(Person): pass p = Person() p.call() s = Student() s.call() 以下是继承的另一种方式。 class Father: def call(self): print('Hello World!') class Son(Father): pass class Grandson(Son): pass gs = Grandson() gs.call() 派生类继承基类的方法后，可以重写基类的方法。 class Person: def call(self): print('Hello World!') class Student(Person): def call(self): print('Hello Python!') p = Person() p.call() s = Student() s.call() 也可以在重写的派生类方法中调用基类的方法。 class Person: def call(self): print('Hello World!') class Student(Person): def call(self): super().call() print('Hello Python!') s = Student() s.call() 在 Python 中同时还支持多继承形式，注意查找顺序为从左到右。 class Father: def call(self): print(__class__) class Mother: def call(self): print(__class__) class Son(Father, Mother): pass s = Son() s.call() "},"docs/面向对象/静态方法.html":{"url":"docs/面向对象/静态方法.html","title":"静态方法","keywords":"","body":"静态方法 可以直接通过类名调用静态方法，而不需要实例化对象。 class Person: @staticmethod def call(): print('Hello World!') Person.call() p = Person() p.call() "},"docs/面向对象/单例模式.html":{"url":"docs/面向对象/单例模式.html","title":"单例模式","keywords":"","body":"单例模式 单例模式是一种创建型设计模式，‌使用单例模式能够确保一个类只有一个实例。 class Singleton(object): obj = None def __new__(cls, *args, **kwargs): if not cls.obj: cls.obj = super().__new__(cls) return cls.obj def __init__(self): print('Hello World!') s1 = Singleton() print(s1, id(s1)) s2 = Singleton() print(s2, id(s2)) "},"docs/面向对象/魔术方法.html":{"url":"docs/面向对象/魔术方法.html","title":"魔术方法","keywords":"","body":"魔术方法 在 Python 中，魔术方法是以双下划线开头和结尾的特殊方法，用于在特定操作时自动触发。 class Person: def __str__(self): return 'str' def __call__(self, *args, **kwargs): print('call', args, kwargs) p = Person() print(p) p() p(1, 2, 3) p(name='Google', site='www.google.com') "}}